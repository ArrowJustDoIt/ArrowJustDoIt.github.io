---
layout: post
title: php递归遍历文件夹
category: php
tags: php
keywords: 
description: 
---

用递归实现遍历文件夹及其子目录
***
###什么是递归
**递归**: 函数不断的调用函数,开辟内存: 是一种典型使用空间换时间的思想(突然间内存被大量占用,效率很高)。

当一个函数是为了解决某一个问题的时候, 发现在解决的过程中, 出现了子问题与本身要解决的问题(父问题)一致: 子问题与父问题一致,只是规模比较小.

如果碰到了相同的问题, 可以使用父问题的解决方案去解决子问题: `调用函数自己`

###递归有两个要素

1 **递归点**: 解决父问题过程中,发现了子问题与父问题一致: 递归点: 递归调用函数

2 **递归出口**: 保证函数能够结束的地方就是递归出口

###思路
1. 使用函数解决当前需要解决的问题: 不考虑子问题

2. 寻找递归点: 函数在解决问题的过程中,有没有碰到与父问题相似的问题: 父问题是遍历文件夹: 子问题: 遍历出来的文件刚好又是文件夹
3. 消除产生死递归的要素: .和..文件夹: 一个代表当前,一个代表上级

4. 递归调用函数: 解决子问题

5. 寻找递归出口: 整个文件夹遍历结束也没有发现文件夹:都是文件或者.和..文件夹

6. 增加子文件的缩进: 子文件夹的遍历都是由上一级发展而来: 如果能够在每一层使用scandir的地方,定义一个层级来控制: 就可以描述当前层级是属于第几级,级别代表当前所属哪层一层文件夹: 级别就代表着缩进

###代码实现

{% highlight php linenos %}
	/*
	 * 实现遍历文件夹及其子目录
	 * @param1 string $dir,要获取文件的路径
	 * @param1 int $level=0,缩进层级
	 * @return 失败返回false 成功返回遍历结果
	*/
	function myscandir($dir, $level = 0){
		//判断路径是否合法
		if(!is_dir($dir)) return false;
		//取出该路径下的所有文件名(以数组的形式)
		$files = scandir($dir);
		//遍历数组
		foreach($files as $file){
			//剔除.与..目录
			if($file != '.' && $file != '..'){		
				//构造新路径
				$new_dir = $dir . '/' . $file;
				//判断输出
				if(is_file($new_dir)){
					//是文件,则以蓝色字体输出
					echo str_repeat('&nbsp;&nbsp', $level * 2),"<font color='blue'>$file</font><br/>";
				}else{
					//是路径,则以红色字体输出并继续遍历
					echo str_repeat('&nbsp;&nbsp', $level * 2),"<font color='red'>$file</font><br/>";
					//递归点
					myscandir($new_dir, $level + 1);
				}
			}
		}
	}
{% endhighlight %}

打完收工:p